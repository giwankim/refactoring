# 7. Encapsulation

코틀린으로 예제들을 학습하고 있는데 여전히 책의 예제들이 Javascript로 되어 있는 부분이 아쉽다. Object literal 사용과 암묵적인 null 사용으로 책의 리팩토링 단계들이 잘 적용이 안 될 때가
있다 (물론 아직 idiomatic 코틀린에 덜 익숙하다). Object literal을 data class로 변경할지 Map으로 작성해야 할지 고민이 되었다.
예제들에서 자주 getter/setter 사용하는 것도 조금 어색한 느낌이긴 한데 생각해보니 결국 까보면 그런 행위가 메서드들 안에서 이루어지니 적합하다는 생각이 든다. 불변객체 사용에 대한 이야기도 종종 나오고
있는데 코틀린에서는 컬렉션을 사용할 때 변경할 수 있는지 제한하는 인터페이스가 있기에 책에서 나온 내용이 자동으로 적용되는 예제들도 있었던 것 같다. 일괄적으로 run static checks라는 단계도 compile error가 다 잡아줄 것 같다.

Perhaps the most important criteria for decomposing modules is to identify secrets that modules should hide from the
rest of the system.

Hide data structures by

- _Encapsulate Record_
- _Encapsulate Collection_

Even primitive data types can be encapsulated with _Replace Primitive with Object_.

Use _Replace Temp with Query_ for temporary variables that get in the way of refactoring.

Form classes with _Combine Functions into Class_. Extract/inline operations also apply to classes with _Extract Class_
and _Inline Class_.

To hide connections between classes, use _Hide Delegate_. If too much hiding leads to bloated interfaces, reverse with
_Remove Middle Man_.

Functions also encapsulate their implementation. Make wholesale change to an algorithm by wrapping it in a function with
_Extract Function_ and _Substitute Algorithm_.

## Encapsulate Record

### Motivation

Simple records have disadvantages: they separate what is stored in the record from calculated values.

Often favor objects over records for mutable data. For immutable value, can use an enrichment step if necessary.

Two kinds of record structures: those where I declare legal field names and those like hash, map, hashmap, dictionary,
or associate array.

### Mechanics

1. _Encapsulate Variable_ on the variable holding the record.
2. Replace the content of the variable with a simple wrapper for the record. Modify the functions that encapsulate the
   variable to use accessors.
3. Test
4. Provide new functions that return the object.
5. For each user of the record, replace the function that returns the record with one that returns the object.

- If it's a complex record, focus on clients that update the data first.

6. Remove the class's raw data accessors and the functions that returned the raw record.
7. Test
8. If the fields of the records are structures, consider using _Encapsulate Record_ and _Encapsulate Collection_
   recursively.

개인적으로 코틀린으로 _Encapsulating a Nested Record_를 적용하는 부분이 상당히
어색했는데 [Refactoring Code to Load a Document](https://martinfowler.com/articles/refactoring-document-load.html)라는 글을
읽어야겠다.

## Encapsulate Collection

객체지향을 처음 배울
때 [The Thoughworks Anthology](https://www.amazon.com/ThoughtWorks-Anthology-Technology-Innovation-Programmers/dp/193435614X)
에 실려있는 Object Calisthenics를 따랐다. 현업에서 적용하기에는 극단적일 수 있지만 그 중, Rule 8: Use First-Class Collections 글이
있다. [일급 컬렉션 (First Class Collection)의 소개와 써야할 이유](https://jojoldu.tistory.com/412)에 더 자세히 설명되어 있다.

### Motivation

If getter for a collection returns itself, then that collection's membership can be altered by the client.

Provide collection modifier methods-usually `add` and `remove`-on the class itself.

Another way is to allow some form of read-only access to the collection.

Probably the most common approach is to provide a getting method for the collection, but make it return a copy of the
underlying collection.

### Mechanics

1. _Encapsulate Variable_ on the collection.
2. Add functions to add and remove elements from the collection.
3. Run static checks.
4. Find all references to the collection. If anyone calls modifiers on the collection, change them to use the new
   add/remove functions. Test after each change.
5. Modify the getter for the collection to return a protected view on it.
6. Test.

## Replace Primitive with Object

### Motivation

### Mechanics

1. _Encapsulate Variable_

## Replace Temp with Query

## Extract Class

## Inline Class

## Hide Delegate

![delegate](delegate.png)

## Remove Middle Man

### Motivation

When the server class becomes just a middle man, and perhaps

### Mechanics

## Substitute Algorithm

### Motivation

Refactoring can break down something complex into simpler pieces, but sometimes I just reach the point at which I have to remove the whole algorithm and replace it with something simpler.

### Mechanics

1. Arrange the code to be replaced so that it fills a complete function.
2. Prepare tests using this function only, to capture its behavior.
3. Prepare your alternative algorithm.
4. Run static checks.
5. Run tests to compare the output of the old algorithm with the new one. If they are the same, you're done. Otherwise, use the old algorithm for comparison in testing and debugging.
